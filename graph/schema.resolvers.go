package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"strconv"

	"github.com/yaninyzwitty/eccomerce-microservices-backend/graph/model"
	"github.com/yaninyzwitty/eccomerce-microservices-backend/pb"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.CreateProductInput) (*model.Product, error) {
	if input.CategoryID == "" || input.Name == "" || input.Description == "" || input.Price == 0 || input.Stock <= 0 {
		return nil, fmt.Errorf("categoryID, name, description, and price are required")
	}

	categoryId, err := strconv.ParseInt(input.CategoryID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid categoryID: %v", err)
	}

	createdProductResponse, err := r.ProductClient.CreateProduct(ctx, &pb.CreateProductRequest{
		CategoryId:  categoryId,
		Name:        input.Name,
		Description: input.Description,
		Price:       float32(input.Price),
		Stock:       input.Stock,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to create product: %v", err)
	}

	createdProductId := strconv.FormatInt(createdProductResponse.Product.Id, 10)
	createdCategoryId := strconv.FormatInt(createdProductResponse.Product.CategoryId, 10)

	return &model.Product{
		ID:          createdProductId,
		CategoryID:  createdCategoryId,
		Name:        createdProductResponse.Product.Name,
		Description: createdProductResponse.Product.Description,
		Price:       float64(createdProductResponse.Product.Price),
		Stock:       createdProductResponse.Product.Stock,
		CreatedAt:   createdProductResponse.Product.CreatedAt.AsTime(),
		UpdatedAt:   createdProductResponse.Product.UpdatedAt.AsTime(),
	}, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.CreateCategoryInput) (*model.Category, error) {
	if input.Name == "" || input.Description == "" {
		return nil, fmt.Errorf("name and description are required")
	}

	createCategoryRequest := &pb.CreateCategoryRequest{
		Name:        input.Name,
		Description: input.Description,
	}

	createdCategoryResponse, err := r.ProductClient.CreateCategory(ctx, createCategoryRequest)
	if err != nil {
		return nil, fmt.Errorf("failed to create category: %v", err)
	}

	createdCategoryId := strconv.FormatInt(createdCategoryResponse.Id, 10)

	return &model.Category{
		ID:          createdCategoryId,
		Name:        createdCategoryResponse.Name,
		Description: createdCategoryResponse.Description,
		CreatedAt:   createdCategoryResponse.GetCreatedAt().AsTime(),
	}, nil
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.CreateOrderInput) (*model.Order, error) {
	if input.UserID == "" || len(input.Items) == 0 {
		return nil, fmt.Errorf("userID and items are required")
	}

	userId, err := strconv.ParseInt(input.UserID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid userID: %v", err)
	}

	orderItems := make([]*pb.OrderItem, len(input.Items))
	// Convert input.Items to orderItems
	for i, item := range input.Items {
		productId, err := strconv.ParseInt(item.ProductID, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid productID: %v", err)
		}
		orderItems[i] = &pb.OrderItem{
			ProductId: productId,
			Quantity:  item.Quantity,
			UnitPrice: float32(item.UnitPrice),
		}
	}

	createOrderRequest := &pb.CreateOrderRequest{
		UserId: userId,
		Items:  orderItems,
	}

	createOrderResponse, err := r.OrderClient.CreateOrder(ctx, createOrderRequest)
	if err != nil {
		return nil, fmt.Errorf("failed to create order: %v", err)
	}

	createdOrderId := strconv.FormatInt(createOrderResponse.Order.Id, 10)
	createdUserId := strconv.FormatInt(createOrderResponse.Order.UserId, 10)

	createdOrderItems := make([]*model.OrderItem, len(input.Items))

	for _, item := range createOrderResponse.Order.Items {
		productId := strconv.FormatInt(item.ProductId, 10)
		createdOrderItems = append(createdOrderItems, &model.OrderItem{
			ProductID: productId,
			Quantity:  item.Quantity,
			UnitPrice: float64(item.UnitPrice),
		})
	}

	return &model.Order{
		ID:         createdOrderId,
		UserID:     createdUserId,
		Items:      createdOrderItems,
		TotalPrice: float64(createOrderResponse.Order.TotalPrice),
		Status:     createOrderResponse.Order.Status,
		CreatedAt:  createOrderResponse.Order.CreatedAt.AsTime(),
		UpdatedAt:  createOrderResponse.Order.UpdatedAt.AsTime(),
	}, nil

}

// Items is the resolver for the items field.
func (r *orderResolver) Items(ctx context.Context, obj *model.Order) ([]*model.OrderItem, error) {

	if obj == nil || len(obj.Items) == 0 {
		return nil, fmt.Errorf("items not provided")
	}
	createdOrderItems := make([]*model.OrderItem, 0, len(obj.Items)) // zero-length slice with capacity

	for _, item := range obj.Items {
		createdOrderItems = append(createdOrderItems, &model.OrderItem{
			ProductID: item.ProductID,
			Quantity:  item.Quantity,
			UnitPrice: item.UnitPrice,
		})

	}

	return createdOrderItems, nil

}

// Category is the resolver for the category field.
func (r *productResolver) Category(ctx context.Context, obj *model.Product) (*model.Category, error) {
	if obj.CategoryID == "" {
		return nil, fmt.Errorf("categoryID not provided")
	}

	categoryId, err := strconv.ParseInt(obj.CategoryID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("failed to parse category id :%v", err)
	}

	categoryResponse, err := r.ProductClient.GetCategory(ctx, &pb.GetCategoryRequest{
		Id: categoryId,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get category: %v", err)

	}

	categoryResponseId := strconv.FormatInt(categoryResponse.Id, 10)

	return &model.Category{
		ID:          categoryResponseId,
		Name:        categoryResponse.Name,
		Description: categoryResponse.Description,
		CreatedAt:   categoryResponse.CreatedAt.AsTime(),
	}, nil
}

// GetProduct is the resolver for the getProduct field.
func (r *queryResolver) GetProduct(ctx context.Context, categoryID string, productID string) (*model.Product, error) {
	if productID == "" {
		return nil, fmt.Errorf("productID not provided")

	}

	productId, err := strconv.ParseInt(productID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("failed  to parse category id :%v", err)
	}

	productResponse, err := r.ProductClient.GetProduct(ctx, &pb.GetProductRequest{
		ProductId: productId,
	})

	categoryId := strconv.FormatInt(productResponse.Product.CategoryId, 10)
	productResponseId := strconv.FormatInt(productResponse.Product.Id, 10)

	if err != nil {
		return nil, fmt.Errorf("failed to get product: %v", err)

	}

	return &model.Product{
		ID:          productResponseId,
		CategoryID:  categoryId,
		Name:        productResponse.Product.Name,
		Description: productResponse.Product.Description,
		Price:       float64(productResponse.Product.Price),
		Stock:       productResponse.Product.Stock,
		CreatedAt:   productResponse.Product.CreatedAt.AsTime(),
		UpdatedAt:   productResponse.Product.UpdatedAt.AsTime(),
		Category: &model.Category{
			ID: categoryID,
		},
	}, nil
}

// GetCategory is the resolver for the getCategory field.
func (r *queryResolver) GetCategory(ctx context.Context, id string) (*model.Category, error) {

	if id == "" {
		return nil, fmt.Errorf("id not provided")
	}
	categoryId, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("failed  to parse category id :%v", err)
	}

	categoryResponse, err := r.ProductClient.GetCategory(ctx, &pb.GetCategoryRequest{
		Id: categoryId,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get category: %v", err)

	}

	categoryResponseId := strconv.FormatInt(categoryResponse.Id, 10)

	return &model.Category{
		ID:          categoryResponseId,
		Name:        categoryResponse.Name,
		Description: categoryResponse.Description,
		CreatedAt:   categoryResponse.CreatedAt.AsTime(),
	}, nil
}

// ListProducts is the resolver for the listProducts field.
func (r *queryResolver) ListProducts(ctx context.Context, categoryID string, pagingState *string, pageSize *int32) (*model.ListProductsResponse, error) {
	panic(fmt.Errorf("not implemented: ListProducts - listProducts"))
}

// GetOrder is the resolver for the getOrder field.
func (r *queryResolver) GetOrder(ctx context.Context, orderID string) (*model.Order, error) {
	panic(fmt.Errorf("not implemented: GetOrder - getOrder"))
}

// ListOrders is the resolver for the listOrders field.
func (r *queryResolver) ListOrders(ctx context.Context, userID string, pagingState *string, pageSize *int32) (*model.ListOrdersResponse, error) {
	panic(fmt.Errorf("not implemented: ListOrders - listOrders"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Order returns OrderResolver implementation.
func (r *Resolver) Order() OrderResolver { return &orderResolver{r} }

// Product returns ProductResolver implementation.
func (r *Resolver) Product() ProductResolver { return &productResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type orderResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
